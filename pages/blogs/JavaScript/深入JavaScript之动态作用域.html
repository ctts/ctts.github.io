<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入JavaScript之从ES规范理解动态作用域（this） | 参天桃树的博客</title>
    <meta name="description" content="前端学习">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/logo.png">
  <link rel="mask-icon" href="/logo.png" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/logo.png">
  <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.25f7d7fa.css" as="style"><link rel="preload" href="/assets/js/app.edf28d47.js" as="script"><link rel="preload" href="/assets/js/2.4ef6d935.js" as="script"><link rel="preload" href="/assets/js/74.1f92351e.js" as="script"><link rel="preload" href="/assets/js/5.03abf982.js" as="script"><link rel="prefetch" href="/assets/js/10.e01bd81c.js"><link rel="prefetch" href="/assets/js/11.4afa66d2.js"><link rel="prefetch" href="/assets/js/12.27402237.js"><link rel="prefetch" href="/assets/js/13.4c78e05f.js"><link rel="prefetch" href="/assets/js/14.0e25cfa1.js"><link rel="prefetch" href="/assets/js/15.b57e640d.js"><link rel="prefetch" href="/assets/js/16.d24a6c01.js"><link rel="prefetch" href="/assets/js/17.08807177.js"><link rel="prefetch" href="/assets/js/18.ccd27d89.js"><link rel="prefetch" href="/assets/js/19.77a1c508.js"><link rel="prefetch" href="/assets/js/20.6634559a.js"><link rel="prefetch" href="/assets/js/21.ca3229d4.js"><link rel="prefetch" href="/assets/js/22.034dd950.js"><link rel="prefetch" href="/assets/js/23.5b932710.js"><link rel="prefetch" href="/assets/js/24.7b9be274.js"><link rel="prefetch" href="/assets/js/25.f4d8458a.js"><link rel="prefetch" href="/assets/js/26.15c95386.js"><link rel="prefetch" href="/assets/js/27.8c8ee964.js"><link rel="prefetch" href="/assets/js/28.90fc886a.js"><link rel="prefetch" href="/assets/js/29.20a5644d.js"><link rel="prefetch" href="/assets/js/3.74bfc25e.js"><link rel="prefetch" href="/assets/js/30.f65d833c.js"><link rel="prefetch" href="/assets/js/31.12ac6fa0.js"><link rel="prefetch" href="/assets/js/32.ebd45b60.js"><link rel="prefetch" href="/assets/js/33.98520712.js"><link rel="prefetch" href="/assets/js/34.07f0ffa1.js"><link rel="prefetch" href="/assets/js/35.f1249471.js"><link rel="prefetch" href="/assets/js/36.a6d2b700.js"><link rel="prefetch" href="/assets/js/37.e4e5625c.js"><link rel="prefetch" href="/assets/js/38.3777bcb4.js"><link rel="prefetch" href="/assets/js/39.3e401e37.js"><link rel="prefetch" href="/assets/js/4.426aadd5.js"><link rel="prefetch" href="/assets/js/40.10f0583d.js"><link rel="prefetch" href="/assets/js/41.b396daed.js"><link rel="prefetch" href="/assets/js/42.b765a524.js"><link rel="prefetch" href="/assets/js/43.b86d742f.js"><link rel="prefetch" href="/assets/js/44.4126af4c.js"><link rel="prefetch" href="/assets/js/45.e194d9df.js"><link rel="prefetch" href="/assets/js/46.9d7acdff.js"><link rel="prefetch" href="/assets/js/47.480c56ee.js"><link rel="prefetch" href="/assets/js/48.1597ebb2.js"><link rel="prefetch" href="/assets/js/49.5478b9e5.js"><link rel="prefetch" href="/assets/js/50.313af1c3.js"><link rel="prefetch" href="/assets/js/51.921ab1ab.js"><link rel="prefetch" href="/assets/js/52.f5a9450f.js"><link rel="prefetch" href="/assets/js/53.8f7435f8.js"><link rel="prefetch" href="/assets/js/54.9045b13e.js"><link rel="prefetch" href="/assets/js/55.541a10ac.js"><link rel="prefetch" href="/assets/js/56.4caa35e3.js"><link rel="prefetch" href="/assets/js/57.06fd5ab7.js"><link rel="prefetch" href="/assets/js/58.8d4f9fd7.js"><link rel="prefetch" href="/assets/js/59.4f366807.js"><link rel="prefetch" href="/assets/js/6.70e2acd4.js"><link rel="prefetch" href="/assets/js/60.b1095e74.js"><link rel="prefetch" href="/assets/js/61.8257724b.js"><link rel="prefetch" href="/assets/js/62.ad94bd6f.js"><link rel="prefetch" href="/assets/js/63.c99ba3c8.js"><link rel="prefetch" href="/assets/js/64.b3edfbdb.js"><link rel="prefetch" href="/assets/js/65.0b71e6e9.js"><link rel="prefetch" href="/assets/js/66.0e57b57e.js"><link rel="prefetch" href="/assets/js/67.7e7020f2.js"><link rel="prefetch" href="/assets/js/68.13ac41db.js"><link rel="prefetch" href="/assets/js/69.a9531cba.js"><link rel="prefetch" href="/assets/js/7.f0104c50.js"><link rel="prefetch" href="/assets/js/70.311a23aa.js"><link rel="prefetch" href="/assets/js/71.6ccff4d3.js"><link rel="prefetch" href="/assets/js/72.91e667a0.js"><link rel="prefetch" href="/assets/js/73.46641548.js"><link rel="prefetch" href="/assets/js/75.83f5aeb6.js"><link rel="prefetch" href="/assets/js/76.f8b2512b.js"><link rel="prefetch" href="/assets/js/77.7f261c27.js"><link rel="prefetch" href="/assets/js/78.1261239b.js"><link rel="prefetch" href="/assets/js/79.50a0eb7b.js"><link rel="prefetch" href="/assets/js/8.8ac9850f.js"><link rel="prefetch" href="/assets/js/80.a7bc59c8.js"><link rel="prefetch" href="/assets/js/81.b54b6ac1.js"><link rel="prefetch" href="/assets/js/82.c78575e0.js"><link rel="prefetch" href="/assets/js/83.bbb61f72.js"><link rel="prefetch" href="/assets/js/84.291ab932.js"><link rel="prefetch" href="/assets/js/85.a88120e1.js"><link rel="prefetch" href="/assets/js/86.8f5ea5c1.js"><link rel="prefetch" href="/assets/js/87.70031702.js"><link rel="prefetch" href="/assets/js/88.0df6111e.js"><link rel="prefetch" href="/assets/js/89.da1becad.js"><link rel="prefetch" href="/assets/js/9.1ee351c7.js"><link rel="prefetch" href="/assets/js/90.ad8d5348.js"><link rel="prefetch" href="/assets/js/91.59c85307.js"><link rel="prefetch" href="/assets/js/92.556598de.js">
    <link rel="stylesheet" href="/assets/css/0.styles.25f7d7fa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="global-layout" data-v-1660a4d0><div class="bg" data-v-be1b9d22 data-v-1660a4d0><canvas data-v-be1b9d22></canvas></div> <div class="theme-container test" data-v-1660a4d0><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="参天桃树的博客" class="logo"> <span class="site-name can-hide">参天桃树的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/blogs/Daily/20210128.html" class="nav-link">
  日常笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/JavaScript/面试题集合.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/CSS/多行文本省略号.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Vue/手把手教你实现一个移动端canvas签名模块.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Design/观察者模式和发布订阅模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Others/手把手教你实现一只node爬虫.html" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  分类
</a></div><div class="nav-item"><a href="/pages/Share/" class="nav-link">
  优秀工具分享
</a></div><div class="nav-item"><a href="/pages/article/" class="nav-link">
  优秀文章分享
</a></div><div class="nav-item"><a href="https://github.com/ctts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博客" class="dropdown-title"><span class="title">博客</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/blogs/Daily/20210128.html" class="nav-link">
  日常笔记
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/JavaScript/面试题集合.html" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/CSS/多行文本省略号.html" class="nav-link">
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Vue/手把手教你实现一个移动端canvas签名模块.html" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Design/观察者模式和发布订阅模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/pages/blogs/Others/手把手教你实现一只node爬虫.html" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于我
</a></div><div class="nav-item"><a href="/guide/" class="nav-link">
  分类
</a></div><div class="nav-item"><a href="/pages/Share/" class="nav-link">
  优秀工具分享
</a></div><div class="nav-item"><a href="/pages/article/" class="nav-link">
  优秀文章分享
</a></div><div class="nav-item"><a href="https://github.com/ctts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/blogs/JavaScript/面试题集合.html" class="sidebar-link">面试题集合</a></li><li><a href="/pages/blogs/JavaScript/网易雷火2020笔试题.html" class="sidebar-link">2020网易雷火笔试题</a></li><li><a href="/pages/blogs/JavaScript/深入JavaScript之词法作用域.html" class="sidebar-link">深入JavaScript之词法作用域</a></li><li><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html" class="active sidebar-link">深入JavaScript之从ES规范理解动态作用域（this）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#什么是this" class="sidebar-link">什么是this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#执行上下文" class="sidebar-link">执行上下文</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#绑定规则（确定this）" class="sidebar-link">绑定规则（确定this）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#默认绑定" class="sidebar-link">默认绑定</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#隐式绑定" class="sidebar-link">隐式绑定</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#显式绑定" class="sidebar-link">显式绑定</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#bind硬绑定" class="sidebar-link">bind硬绑定</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#new绑定" class="sidebar-link">new绑定</a></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#箭头函数" class="sidebar-link">箭头函数</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/blogs/JavaScript/深入JavaScript之动态作用域.html#写在最后" class="sidebar-link">写在最后</a></li></ul></li><li><a href="/pages/blogs/JavaScript/模拟移动端长按事件.html" class="sidebar-link">移动端长按事件</a></li><li><a href="/pages/blogs/JavaScript/封装axios和cookie.html" class="sidebar-link">封装axios和cookie小笔记</a></li><li><a href="/pages/blogs/JavaScript/定位鼠标点击位置和目标元素相对位置.html" class="sidebar-link">定位鼠标点击位置和目标元素相对位置</a></li><li><a href="/pages/blogs/JavaScript/学会使用async来实现异步编程.html" class="sidebar-link">学会使用async来实现异步编程</a></li><li><a href="/pages/blogs/JavaScript/图片懒加载.html" class="sidebar-link">图片（pdf）懒加载</a></li><li><a href="/pages/blogs/JavaScript/前端实现复制粘贴.html" class="sidebar-link">前端实现复制粘贴</a></li><li><a href="/pages/blogs/JavaScript/Koa学习指南.html" class="sidebar-link">Koa学习指南</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="深入javascript之从es规范理解动态作用域（this）"><a href="#深入javascript之从es规范理解动态作用域（this）" class="header-anchor">#</a> 深入JavaScript之从ES规范理解动态作用域（this）</h1> <img src="https://s1.ax1x.com/2020/03/18/8DkhKP.jpg" alt="8DkhKP.jpg" border="0"> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <blockquote><p>虽然标题说的是动态作用域，但是第一要明确的是，<strong>JavaScript 其实不存在动态作用域，只存在词法作用域</strong>。只是 this 的形态和机制和动态作用域太相像了，所以我们直接用方便理解的动态作用域来理解。虽说 JavaScript 的 this 是公认的难以理解，但是不管是Vue开发还是React，this出现的频率都是很高的。那么今天就来真正深入地了解了解 this 吧。</p></blockquote> <p>我是练习时长两年半的前端实习生（误）小c，看看今天有什么博客好看的，动态作用域？没听说过，懒得看。ctrl+f4再见。（常规开局）</p> <p>开始快乐的学习时间，看看笔试题吧。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'global'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'local'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> bar3 <span class="token operator">=</span> bar2 <span class="token operator">=</span> bar<span class="token punctuation">;</span>
bar2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'foo2'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar3<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><img src="https://s1.ax1x.com/2020/03/15/83kbRA.jpg" alt="83kbRA.jpg" border="0"> <p>这代码是人写出来的吗？？？</p> <p>答案是：</p> <div class="language- extra-class"><pre class="language-text"><code>foo
foo2
global
</code></pre></div><p>…默默打开关掉的博客。</p> <h2 id="什么是this"><a href="#什么是this" class="header-anchor">#</a> 什么是this</h2> <blockquote><p>在之前我们讲了<strong>静态作用域</strong>，接下来我们要做的事情就是：把之前将的全部忘掉！在使用this时，不要使用任何关于静态作用域的知识点！</p></blockquote> <p>对this的常见误区(注意！以下为错误观点)：</p> <p>1.this指向function本身。X</p> <p>2.this指向function的词法作用域。X</p> <p>其实以上两点是新手经常会犯的错误，我们只需要看到两个例子就可以解决这个问题。</p> <p>例1：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

test<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">2</span>

<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>num<span class="token punctuation">)</span> <span class="token comment">// 1</span>
</code></pre></div><p>答案并不是我们所期待的 <code>1 ,undefined</code>，而是 <code>2 ，1</code>。这充分地说明了第一点，<strong>this并不指向function本身</strong>，那么 test 中的this指向谁呢？从下面的<code>window.mun = 1</code> 我们可以看出来指向了 window ，原因会在下文引出。</p> <p>例2：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">test1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span>
	<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><p>答案也并非我们期望的 1 ，而是 undefined 。这也正如上文的第二点：<strong>this并非指向当前function的词法作用域</strong></p> <hr> <p>那么this到底是什么呢？</p> <blockquote><p>引自<a href="https://ecma-international.org/ecma-262/5.1/#sec-11.1.1" target="_blank" rel="noopener noreferrer">《ECMAScript标准规范》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>The <code>this</code> keyword evaluates to the value of the ThisBinding of the current execution context.</p> <p>译：<code>this</code>关键字代表的是当前<strong>执行上下文</strong>的 <code>thisBinding</code></p></blockquote> <img src="https://s1.ax1x.com/2020/03/21/8WBkOf.jpg" alt="8WBkOf.jpg" border="0" height="200"> <blockquote><p>小c：“说的是啥呀，谁听得懂呀？”</p></blockquote> <p>虽然讲解一个抽象的东西最愚蠢的方法就是用另一个抽象的东西来比喻它，但是毕竟是<strong>深入JavaScript</strong>，有些概念还是必须知道的。</p> <p>通过这段话，我们知道了<strong>this</strong>，其实是由两个关键字决定的，执行上下文、thisBinding 。</p> <p>理解这段话的前提是知道什么是<strong>执行上下文</strong>。</p> <h3 id="执行上下文"><a href="#执行上下文" class="header-anchor">#</a> 执行上下文</h3> <ol><li>JavaScript 开始执行全局代码时，就会创建一个执行栈（后进先执行）</li> <li>每遇到一次函数调用，就生成执行上下文，放入栈顶，执行当前函数代码</li> <li>若继续遇到内部函数调用，重复第2步，否则执行完毕，并从栈中弹出当前执行上下文</li> <li>继续执行栈顶的执行上下文函数，直到栈空</li></ol> <p>当 JavaScript 开始执行一段代码时，若遇到套嵌的函数，并非以队列（先进先执行）的形式执行，而是以栈（后进先执行）的形式执行这段代码，这其实很常见，如：</p> <div class="language- extra-class"><pre class="language-text"><code>function test1(){
	console.log(1)
	test2()
}

function test2(){
    console.log(2)
    test3()
}

function test3(){
    console.log(3)
    test4()
}

function test4(){
    console.log(4)
    test5()
}

function test5(){
    console.log(5)
}

test1()
</code></pre></div><p>再生动的代码也比不上动图展示来的好理解！</p> <img src="https://s1.ax1x.com/2020/03/21/8hhE7j.gif" alt="8hhE7j.gif" border="0"> <p>在这里安利一个用来理解执行栈和时间循环的网站 <a href="http://latentflip.com/loupe/?code=ZnVuY3Rpb24gdGVzdDEoKXsNCgljb25zb2xlLmxvZygxKQ0KCXRlc3QyKCkNCn0NCg0KZnVuY3Rpb24gdGVzdDIoKXsNCiAgICBjb25zb2xlLmxvZygyKQ0KICAgIHRlc3QzKCkNCn0NCg0KZnVuY3Rpb24gdGVzdDMoKXsNCiAgICBjb25zb2xlLmxvZygzKQ0KICAgIHRlc3Q0KCkNCn0NCg0KZnVuY3Rpb24gdGVzdDQoKXsNCiAgICBjb25zb2xlLmxvZyg0KQ0KICAgIHRlc3Q1KCkNCn0NCg0KZnVuY3Rpb24gdGVzdDUoKXsNCiAgICBjb25zb2xlLmxvZyg1KQ0KfQ0KDQp0ZXN0MSgp!!!" target="_blank" rel="noopener noreferrer">loupe<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，是大佬 Philip Roberts 在 <strong>jsconf</strong> 中用来展示事件循环的工具。</p> <p>自己动手执行一边，配合上面的文字讲解，你要是看了三遍还不懂，拿刀来砍我，好伐？</p> <blockquote><p>小c：“那么 执行上下文 和 this 有什么关系呢？”</p></blockquote> <p>别急，我们回到上面那句话：<code>this</code>关键字代表的是当前<strong>执行上下文</strong>的 <code>thisBinding</code>、</p> <p>我们搞清楚了 执行上下文 ，那么我们来看看 什么是 thisBinding。继续看文档，</p> <p><strong>Table 19 —Execution Context State Components</strong></p> <table><thead><tr><th>Component</th> <th>Purpose</th></tr></thead> <tbody><tr><td>LexicalEnvironment</td> <td>Identifies the <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.2" target="_blank" rel="noopener noreferrer">Lexical Environment<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> used to resolve identifier references made by code within this execution context.</td></tr> <tr><td>VariableEnvironment</td> <td>Identifies the <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.2" target="_blank" rel="noopener noreferrer">Lexical Environment<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> whose environment record holds bindings created by <em>VariableStatements</em> and <em>FunctionDeclarations</em> within this execution context.</td></tr> <tr><td>ThisBinding</td> <td><strong>The value associated with the <code>this</code> keyword within ECMAScript code associated with this execution context.</strong>（这个值在这个执行上下文中会和关键字this联系起来）</td></tr></tbody></table> <p>读完这个表我们终于找到了 this 和 thisBinding 和 执行上下文的关系。</p> <ol><li>每当执行一个函数时，系统会生成一个 执行上下文</li> <li>每个执行上下文生成时就需要确定三个属性：创建词法环境、创建变量环境、<strong>ThisBinding（也就是确定this的值）</strong></li></ol> <p>前两者不再本文的讨论范围。</p> <p>继续往下看文档，</p> <blockquote><p>The following steps are performed when control enters the execution context for function code contained in function object F, a caller provided thisArg, and a caller provided argumentsList:</p> <ol><li>If the function code is <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.1.1" target="_blank" rel="noopener noreferrer">strict code<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, set the <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener noreferrer">ThisBinding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> to <em>thisArg</em>.</li> <li>Else if <em>thisArg</em> is <strong>null</strong> or <strong>undefined</strong>, set the <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener noreferrer">ThisBinding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> to the global object.</li> <li>Else if <a href="https://ecma-international.org/ecma-262/5.1/#sec-8" target="_blank" rel="noopener noreferrer">Type<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>(<em>thisArg</em>) is not Object, set the <a href="https://ecma-international.org/ecma-262/5.1/#sec-10.3" target="_blank" rel="noopener noreferrer">ThisBinding<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> to <a href="https://ecma-international.org/ecma-262/5.1/#sec-9.9" target="_blank" rel="noopener noreferrer">ToObject<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>(<em>thisArg</em>).</li></ol></blockquote> <p>本人翻译（看得懂英文忽略）：</p> <blockquote><p>当执行进入函数对象的执行上下文时，<strong>函数调用者</strong>会提供 <strong>thisArg</strong> 和 argumentsList ，并执行以下步骤（我截取了仅跟this操作有关的步骤）：</p> <ol><li>如果这个 function 处于严格模式下，让 <strong>ThisBinding</strong> 等于 <strong>thisArg</strong></li> <li>否则，若不是严格模式下，并且 <strong>thisArg</strong> 的值为 null 或 undefined ，让 <strong>ThisBinding</strong> 等于 global</li> <li>否则，若 <strong>thisArg</strong> 的类型不是 Object，将 <strong>thisArg</strong> 转化为Object, 让 <strong>ThisBinding</strong> 等于 thisArg</li> <li>若非以上的情况，让 <strong>ThisBinding</strong> 等于 <strong>thisArg</strong></li></ol></blockquote> <p>我们又将目光投向了 thisArg ，终于看到一个比较眼熟的东西了，感动的热泪盈眶。</p> <img src="https://s1.ax1x.com/2020/03/23/87fJnP.jpg" alt="87fJnP.jpg" border="0"> <p>我们最常见到thisArg的地方就是 <code>Function.prototype.call()</code></p> <img src="https://s1.ax1x.com/2020/03/23/87fj9H.png" alt="87fj9H.png" border="0"> <p>好了，我们整理一下思路：</p> <p>执行上下文 =》 ThisBinding =》 thisArg</p> <ol><li>函数执行（被调用），创建了一个执行上下文</li> <li>创建时所作的第一步，就是给执行上下文的 ThisBinding 属性赋值</li> <li>ThisBinding 属性赋值的流程就是上文的 thisArg 四步判断</li></ol> <p>最终，编译器把 thisArg 赋值给了 this ，也就是我们用到的 this 了！</p> <h2 id="绑定规则（确定this）"><a href="#绑定规则（确定this）" class="header-anchor">#</a> 绑定规则（确定this）</h2> <p>上面我们从标准规范的角度理解了一般情况下 Function 中的 this，如果现在我们来系统地将绑定分一下类。</p> <p>如果真正看懂了上文，那么以下的内容是很简单的。</p> <h3 id="默认绑定"><a href="#默认绑定" class="header-anchor">#</a> 默认绑定</h3> <p>这是最常见的绑定，也就是<strong>独立函数调用</strong>，这种调用我们其实可以理解为 window 在调用这个 function ，自然而然就是 window 提供 thisArg ， 所以 this 的值也就指向了 window （严格模式下为undefined）。这个行为对应了上文的</p> <blockquote><ol><li>如果这个 function 处于严格模式下，让 <strong>ThisBinding</strong> 等于 <strong>thisArg</strong>否则，</li> <li>若不是严格模式下，并且 <strong>thisArg</strong> 的值为 null 或 undefined ，让 <strong>ThisBinding</strong> 等于 global</li></ol></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// window</span>
</code></pre></div><p>很好理解。</p> <h3 id="隐式绑定"><a href="#隐式绑定" class="header-anchor">#</a> 隐式绑定</h3> <p>为什么叫它隐式绑定呢？因为<strong>它没有明确的告诉你 this 指向谁</strong>，还需要你去猜！</p> <img src="https://s1.ax1x.com/2020/03/23/8H4tCF.jpg" alt="8H4tCF.jpg" border="0"> <p>当函数的<strong>调用者是一个对象</strong>时,或者说函数是某个对象属性时，也就是对象隐式提供 thisArg ，那么自然 this 也就指向了调用对象。值得注意的是，套嵌对象调用方法时，this指向的是最后调用的对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	a<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
	o<span class="token operator">:</span><span class="token punctuation">{</span>
		a<span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
		func<span class="token operator">:</span>func
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>o<span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><p>还有一种隐式调用，那就是<strong>函数以参数的形式被传递调用</strong>，</p> <p>但是这种隐式绑定有个致命的问题，它会发生<strong>隐式丢失</strong>！</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'global'</span>
<span class="token keyword">function</span> <span class="token function">doTest</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">'obj'</span><span class="token punctuation">,</span>
    fn<span class="token operator">:</span> test
<span class="token punctuation">}</span>
<span class="token function">doTest</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>fn<span class="token punctuation">)</span> <span class="token comment">// global</span>
</code></pre></div><p>我们可以看到传递时函数确实是被<code>obj</code>调用，但是打印出来的确实 global。这个问题可以从另个角度来解决。</p> <p>JavaScript传参的有两种形式：1.按值传递、2.按引用传递。</p> <p>当参数类型是<strong>基本数据类型</strong>时，一律是按值传递的，也就是传递的是一个副本，你在函数内部改变形参并不会改变外部的变量本身。</p> <p>当参数类型时引用类型时（function是特殊的Object），传递的是一个引用，这个引用指向的是引用类型本身，（这里不展开讲，要不然又是一篇文章）所以当作参数时，**<code>test</code>函数已经不算是obj的属性了，它就是它自己，**一个普通的函数，<strong>隐式绑定就转化为了默认绑定</strong>，所以以上代码可以转化为：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'global'</span>
<span class="token keyword">function</span> <span class="token function">doTest</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">doTest</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">// 传递的是引用，所以 obj.fn 就是 test 本身，所以变成了默认绑定</span>
</code></pre></div><p>隐式丢失部分有些难以理解，建议多花些时间理解。</p> <h3 id="显式绑定"><a href="#显式绑定" class="header-anchor">#</a> 显式绑定</h3> <p>显式绑定是我们比较提倡的绑定 this 的方式,也就是显式地告诉函数this指向谁，也就是使用 <code>call()</code> <code>apply()</code> <code>bind</code> 这三个方法，这三个函数的用法不多说。</p> <p>其实理解这三个函数的最好方法就是自己模拟一个，而且并不困难，是常规的面试题之一。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// call 和 apply 通用</span>
<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">call</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">const</span> fn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 为了不覆盖context原本的属性，要确定fn是唯一的，所以使用symbol类型</span>
    context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token comment">// ？？？</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 隐式绑定this，调用函数，此为简易版，不添加参数，只绑定this</span>
    <span class="token keyword">delete</span> context<span class="token punctuation">[</span>fn<span class="token punctuation">]</span> <span class="token comment">// 删除对象上挂载的属性</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到，其实 显示绑定 的原理就是 <strong>在函数内部实现一个隐式绑定</strong> ，不同的是，内部隐式绑定的对象是我们自己指定的，增强了可读性和可控性。</p> <p>这里最有疑问的一步就在于第二步，灵魂四问：</p> <p>此时的 this 为什么是函数本身？而且可以直接被调用执行？this不应该指向对象吗？对象还能被执行？</p> <img src="https://s1.ax1x.com/2020/03/25/8XVJKK.jpg" alt="8XVJKK.jpg" border="0"> <p>现有的知识已经无法帮我解决问题了，<strong>查文档吧</strong>。</p> <blockquote><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-properties-of-the-function-prototype-object" target="_blank" rel="noopener noreferrer">ecma-262<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>The Function prototype object is the intrinsic object %FunctionPrototype%. The Function prototype object is itself a built-in function object. When invoked, it accepts any arguments and returns <strong>undefined</strong>. It does not have a [[Construct]] internal method so it is not a constructor.</p></blockquote> <p>译：</p> <p>函数原型对象是内部对象 %FunctionPrototype% 。<strong>prototype 本身就是一个内置的函数对象</strong>。在调用时，它接受任何参数并返回 undefined 。它没有[[Construct]]内部方法，所以它不是一个构造函数。</p> <p>…简单来说它即是函数又是对象？？？在文档下面还加了一段提示：</p> <blockquote><p>The Function prototype object is specified to be a function object to ensure compatibility with ECMAScript code that was created prior to the ECMAScript 2015 specification.</p></blockquote> <p>译：</p> <p>函数原型对象被指定为一个函数对象，以确保与ECMAScript代码的兼容性，该代码是在ECMAScript 2015规范之前创建的。</p> <p>总而言之：prototype 既是对象又是函数（存疑），所以<code>context[fn] = this</code>此时的 this 就是调用 call 的函数本身，并且在下一步中对其进行调用。</p> <p>这一步可以解释通了。</p> <h3 id="bind硬绑定"><a href="#bind硬绑定" class="header-anchor">#</a> bind硬绑定</h3> <p>虽然已经有了 <code>call</code> <code>apply</code>，但是这并不能满足我们的需求。我们可以发现，call和apply会 <strong>立即执行</strong>这个函数，有些时候我们并不想那么做，我们只是想把这个函数指向改变，并保存下来，等到需要时进行调用。</p> <p>其实原理也很简单，<strong>在外面再包一层壳不就好了</strong>…</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">bind</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 返回一个匿名函数</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// 每次调用匿名函数就是调用一次call</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>理解<code>bind</code>的关键就在于：bind返回的是一个<strong>全新的函数</strong>，已经不是我们传入的函数本身了。</p> <p>为bind函数处理过的函数继续执行 call 是无效的，因为到最后，bind内部依然会执行自己的最后一次call ！被bind绑定过后就无法更改指向了！所以bind被称为<strong>硬绑定</strong></p> <p><code>bind</code>在react中运用十分频繁，理解bind还是很重要的。</p> <h3 id="new绑定"><a href="#new绑定" class="header-anchor">#</a> new绑定</h3> <p>new是一个操作符，可以创建一个对象，我们用一个函数来模拟一下</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 简易版，构造函数不返回值，旨在理解其中this，不涉及具体操作</span>
<span class="token keyword">function</span> <span class="token function">createObj</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>fn<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
	<span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
	<span class="token keyword">return</span> obj
<span class="token punctuation">}</span>
</code></pre></div><p>来简略说说new的过程吧：</p> <ol><li>创建一个空对象</li> <li><strong>将构造函数的属性和作用域赋值给新对象</strong>（此处直接使用<code>Object.create()完成了1、2两步</code>）</li> <li><strong>这个对象会绑定到函数调用的this</strong></li> <li>如果构造函数没有返回其他对象，那么返回obj</li></ol> <p>由于第二步和第三步，所以这个新对象的所有属性和方法默认都是指向这个 obj 的</p> <h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>一句话，<strong>箭头函数没有自己的this</strong>，因为没有自己的，自然也就只能问爸爸要了（外部作用域）。</p> <p>很多人是自以为理解了这句话，来一道题。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Outer</span> <span class="token punctuation">(</span><span class="token parameter">fg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    o<span class="token punctuation">.</span>flag <span class="token operator">=</span> fg
    o<span class="token punctuation">.</span><span class="token function-variable function">getval</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token comment">// 区别</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> o
<span class="token punctuation">}</span>
<span class="token keyword">let</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
outer<span class="token punctuation">.</span><span class="token function">getval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ?</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Outer</span> <span class="token punctuation">(</span><span class="token parameter">fg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    o<span class="token punctuation">.</span>flag <span class="token operator">=</span> fg
    o<span class="token punctuation">.</span><span class="token function-variable function">getval</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 区别</span>
		console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> o
<span class="token punctuation">}</span>
<span class="token keyword">let</span> outer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Outer</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
outer<span class="token punctuation">.</span><span class="token function">getval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ?</span>
</code></pre></div><p>答案:</p> <p>1.<code>Outer {}</code></p> <p>2.<code>{flag: &quot;test&quot;, getval: ƒ}</code></p> <p>第 2 题，很好理解，我们可以看到唯一的区别就在于在构造函数内使用了箭头函数。</p> <p>我们分析一下第 1 题，<strong>由于箭头函数没有自己的this</strong>，所以此时的this就是父级的this，那我们直接分析父级的this，由于使用了<code>new</code>操作符<code>let outer = new Outer('test')</code>，所以此时的this已经绑定在了 outer 对象，所以是一个空对象。</p> <h2 id="写在最后"><a href="#写在最后" class="header-anchor">#</a> 写在最后</h2> <ol><li>以上代码仅是模拟函数（call/bind/new），并非真实JavaScript源码，源码肯定没那么简单！</li> <li>本文信息量极大，涉及到了：作用域、new、call、执行上下文、执行栈等知识点，若不理解可以搭配其他文章一起理解</li> <li>本文看一遍应该无法完全理解…建议多看几遍</li></ol> <blockquote><p>小c：“看了那么久，直接看绑定规则不就完事了吗？前面的理论有啥用啊？”</p></blockquote> <p>我感觉有很多人都会有这种观点，看了文档有啥了不起的，平时又用不上，除了能拿出去装X还能干啥…</p> <p>有些东西仅仅知道怎么用确实够了，但是遇到现有的教程也没说到的问题，那么去哪里找答案呢？我们无法看到JavaScript内部运行的代码，但是我们可以通过文档知道它运行的逻辑，通过它的逻辑，从根源解决问题。</p> <p>所以深入还是要靠文档，学会看文档是你突破瓶颈的方法之一！</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/18/2020, 5:51:53 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/pages/blogs/JavaScript/深入JavaScript之词法作用域.html" class="prev">
        深入JavaScript之词法作用域
      </a></span> <span class="next"><a href="/pages/blogs/JavaScript/模拟移动端长按事件.html">
        移动端长按事件
      </a>
      →
    </span></p></div> </main></div></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.edf28d47.js" defer></script><script src="/assets/js/2.4ef6d935.js" defer></script><script src="/assets/js/74.1f92351e.js" defer></script><script src="/assets/js/5.03abf982.js" defer></script>
  </body>
</html>
