(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{362:function(t,e,n){"use strict";n.r(e);var a=n(14),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"vue事件监听"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue事件监听"}},[t._v("#")]),t._v(" Vue事件监听")]),t._v(" "),n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("blockquote",[n("p",[t._v("当你遇到问题时，官方文档才是你解决问题最好的地方")])]),t._v(" "),n("h2",{attrs:{id:"问题一：在父组件中定义的方法不触发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#问题一：在父组件中定义的方法不触发"}},[t._v("#")]),t._v(" 问题一：在父组件中定义的方法不触发")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<template>\n  <div>\n    <sub @click=\"handleClick\"></sub>  //此处的点击事件不触发\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'father',\n  data () {\n    return {\n      num: 0\n    }\n  },\n  methods: {\n    handleClick () {\n      this.num++\n    }\n  },\n}\n<\/script>\n")])])]),n("p",[t._v("查阅官方文档：")]),t._v(" "),n("blockquote",[n("p",[t._v("你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(' <sub @click.native="handleClick"></sub>  \n \n')])])]),n("p",[t._v("这样就可以正确的监听原生事件了。（此处的原生事件指的是父组件上的方法）")]),t._v(" "),n("p",[n("strong",[t._v("注意")]),t._v("：.native不使用于类似"),n("code",[t._v("<input>")]),t._v("的元素。")]),t._v(" "),n("h2",{attrs:{id:"问题二：父组件和子组件同时触发了事件，谁先触发"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#问题二：父组件和子组件同时触发了事件，谁先触发"}},[t._v("#")]),t._v(" 问题二：父组件和子组件同时触发了事件，谁先触发")]),t._v(" "),n("p",[t._v("我还没有发现触发的顺序是怎么规定的……有时候子组件快有时候父组件快，但是我们可以用事件修饰符来规定哪个组件先触发。")]),t._v(" "),n("p",[t._v("查阅官方文档：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\x3c!-- 添加事件监听器时使用事件捕获模式 --\x3e\n\x3c!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --\x3e\n<div v-on:click.capture="doThis">...</div>\n\n\x3c!-- 只当在 event.target 是当前元素自身时触发处理函数 --\x3e\n\x3c!-- 即事件不是从内部元素触发的 --\x3e\n<div v-on:click.self="doThat">...</div>\n')])])]),n("p",[t._v("使用这两个方法中的一个就可以自己指定一个规则了。这个问题很隐蔽，可能只有遇到过一次才能记忆深刻吧。")]),t._v(" "),n("h2",{attrs:{id:"所有事件修饰符"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#所有事件修饰符"}},[t._v("#")]),t._v(" 所有事件修饰符")]),t._v(" "),n("p",[t._v("摘抄自Vue官方文档  https://cn.vuejs.org/v2/guide/events.html")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('\x3c!-- 阻止单击事件继续传播 --\x3e\n<a v-on:click.stop="doThis"></a>\n\n\x3c!-- 提交事件不再重载页面 --\x3e\n<form v-on:submit.prevent="onSubmit"></form>\n\n\x3c!-- 修饰符可以串联 --\x3e\n<a v-on:click.stop.prevent="doThat"></a>\n\n\x3c!-- 只有修饰符 --\x3e\n<form v-on:submit.prevent></form>\n\n\x3c!-- 添加事件监听器时使用事件捕获模式 --\x3e\n\x3c!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --\x3e\n<div v-on:click.capture="doThis">...</div>\n\n\x3c!-- 只当在 event.target 是当前元素自身时触发处理函数 --\x3e\n\x3c!-- 即事件不是从内部元素触发的 --\x3e\n<div v-on:click.self="doThat">...</div>\n\n\x3c!-- 点击事件将只会触发一次 --\x3e\n<a v-on:click.once="doThis"></a>\n\n\x3c!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --\x3e\n\x3c!-- 而不会等待 `onScroll` 完成  --\x3e\n\x3c!-- 这其中包含 `event.preventDefault()` 的情况 --\x3e\n<div v-on:scroll.passive="onScroll">...</div>\n')])])]),n("h2",{attrs:{id:"感悟"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#感悟"}},[t._v("#")]),t._v(" 感悟")]),t._v(" "),n("p",[t._v("官方文档！官方文档！官方文档！很重要！要反复看！不一定要记住，但是一定要知道有那么个东西！")])])}),[],!1,null,null,null);e.default=s.exports}}]);