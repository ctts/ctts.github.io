(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{349:function(e,n,s){"use strict";s.r(n);var a=s(14),t=Object(a.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"学会使用async-await来实现异步编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学会使用async-await来实现异步编程"}},[e._v("#")]),e._v(" 学会使用async/await来实现异步编程")]),e._v(" "),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("还在被回调地狱给困扰着吗？赶紧来学习async吧。在学习async之前，每当接触到异步操作时，都会很头疼，因为遇到异步，就意味着代码会变得异常复杂难懂，而且变得凌乱。而使用了async之后，把异步代码当作同步来看待，语义更棒，可读性更好，大大增加了代码的质量。同时，这也是学习node必不可少的大前提。")])]),e._v(" "),s("h2",{attrs:{id:"基础前提"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础前提"}},[e._v("#")]),e._v(" 基础前提")]),e._v(" "),s("p",[e._v("一句话概括async的本质就是"),s("strong",[e._v("promise和generator函数的语法糖")]),e._v("。")]),e._v(" "),s("p",[e._v("所以，我们第一步所要做的就是先理解"),s("strong",[e._v("promise")]),e._v("和"),s("strong",[e._v("generator")]),e._v("函数。已了解的可直接转往async/await")]),e._v(" "),s("h2",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" promise")]),e._v(" "),s("p",[e._v("说它是es6最重要的语法特性也不为过，也是控制异步操作的核心。")]),e._v(" "),s("p",[e._v("看着代码来解释，先来看看一个普通的异步操作如何通过promise实现")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function learnPromise() {\n    setTimeout(() => {  //耗时操作\n        console.log('first')\n    }, 2000);\n\n    console.log('second')\n    \n    //second  first\n})()\n")])])]),s("p",[e._v("我需要先打印first，再打印second，如何操作呢")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("(function learnPromise() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log('first')\n            resolve()\n        }, 2000);\n    })\n    promise.then(() => {\n        console.log('second')\n    }).catch((err) => {\n        console.log(err)\n    })\n    \n    //first second \n})()\n")])])]),s("p",[e._v("这里就要引出promise的三个状态：pending（等待）、resolve（成功）、reject（失败），也就是 "),s("code",[e._v("let promise = new Promise((resolve, reject) => {})")]),e._v(" 中的resolve和reject。")]),e._v(" "),s("p",[e._v("当代码执行到promise时，promise会处于pending状态，等待状态的改变。当状态发生改变后，若成功（resolve()），才会执行then方法, 若失败（reject（）），则胡执行catch方法。这就实现了异步操作的同步化。")]),e._v(" "),s("p",[e._v("当有多个异步操作时，我们可以这么写")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function learnPromise() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log('first')\n            resolve()\n        }, 2000);\n    })\n    return promise\n}\n\nfunction otherPromise() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log('second')\n            resolve()\n        }, 2000);\n    })\n    return promise\n}\n\n// 主流程函数，在这里管理所有promise\n(function race() {\n    let promise = learnPromise()\n    promise.then(() => {\n        return otherPromise()\n    }).then(() => {\n        console.log('third')\n    })\n})()\n")])])]),s("p",[e._v("这样可以更清晰地理解代码的含义，每个函数只需要管理自己的操作，代码耦合度更低，更好地实现了异步操作的同步化。")]),e._v(" "),s("p",[s("strong",[e._v("重点： promise的构造函数内部是同步执行的，then方法才是异步执行的，then方法类似于回调函数。所以本质上promise只是改善了回调函数，而不是真正的解决了异步编程问题。")])]),e._v(" "),s("p",[e._v("注意：上面存在promise的链式调用，注意点在于想要实现链式调用一定要在 then 方法里"),s("strong",[e._v("返回（return）一个promise对象")]),e._v("，否则视为第一个promise执行的回调方法！这是一个新手常见错误。")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("promise的基本用法就是以上。 更多关于promise的知识，我推荐大家去看"),s("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/promise#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[e._v("阮一峰老师的es6入门"),s("OutboundLink")],1),e._v("可以更系统的学习promise。")])]),e._v(" "),s("h2",{attrs:{id:"generator函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#generator函数"}},[e._v("#")]),e._v(" generator函数")]),e._v(" "),s("p",[e._v("我觉得generator比promise稍微难理解一些。")]),e._v(" "),s("p",[e._v("借用es6入门里的一句话：")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("generator 函数可以把它理解成一个"),s("strong",[e._v("状态机")]),e._v("，还是一个"),s("strong",[e._v("历遍器对象生成")]),e._v("函数。")])]),e._v(" "),s("p",[e._v("简单来说，它的最主要的特性就是**“函数内部分段执行”"),s("strong",[e._v("，交出当前代码执行权，分段的标记就是")]),e._v("yield**，使用next方法可以恢复执行。")]),e._v(" "),s("p",[e._v("generator函数功能很强大，但是我们回到异步转同步的话题。")]),e._v(" "),s("p",[e._v("如何用generator来处理异步方法呢？上面说到它可以交出函数执行权，也就是说，\n"),s("strong",[e._v("当我们遇到异步操作时，只需要先交出执行权，等待异步操作执行完毕，再恢复代码执行权，继续执行即可。"),s("strong",[e._v("但是generator有个")]),e._v("致命的缺点就是需要我们手动执行 next 方法")]),e._v("，也就是每段操作后需要跟一个 "),s("code",[e._v("next()")]),e._v(" 。这不是我们想要的。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('// generator异步操作例子\nfunction* main() {\n  var result1 = yield request("http://some.url");\n  var result2 = yield request("http://other.url");\n}\n \nfunction request(url) {\n  makeAjaxCall(url, function(response){\n    it.next(response);\n  });\n}\n \nvar it = main();\nit.next();\n')])])]),s("p",[e._v("要注意的是yield后面必须跟着")]),e._v(" "),s("p",[e._v("为了解决手动执行 next() 的问题，有人发明了"),s("strong",[e._v("co模块")]),e._v("，它可以自动帮我们执行generator函数的next方法。但是现在基本已经被async取代了，所以就不深入了解co了。")]),e._v(" "),s("h2",{attrs:{id:"async-await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await"}},[e._v("#")]),e._v(" async/await")]),e._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),s("p",[e._v("广大前端开发者给予async的评价：异步操作的终极解决方法。")])]),e._v(" "),s("p",[e._v("终于来到了我们的重点：async/await, 回到开头的那句话："),s("strong",[e._v("async的本质就是promise和generator函数的语法糖")]),e._v("。")]),e._v(" "),s("p",[e._v("先来一段async函数看看它的庐山真面目：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function handler() {\n  const result1 = await asyncfunc1();\n  const result2 = await asyncfunc2(result1);\n  return result2;\n}\nhandler()\n")])])]),s("p",[e._v("是不是感觉和上面的generator有异曲同工之妙，那是因为他们本来就是亲戚。")]),e._v(" "),s("p",[e._v("但是它不需要next()来执行，async后面可以是任意类型，语法简洁，语义明确，实乃异步操作的最终解决手段！")]),e._v(" "),s("p",[e._v("以上是async的基本用法，我们来看看一些特殊情况。")]),e._v(" "),s("h3",{attrs:{id:"_1-async内发生错误的情况"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-async内发生错误的情况"}},[e._v("#")]),e._v(" 1.async内发生错误的情况")]),e._v(" "),s("p",[e._v("以前使用回调函数实现异步操作的问题之一就是难以差错，try/catch无法捕捉异步操作传出的错误，如：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function main() {\n  try {\n    setTimeout(() => {\n      throw new Error('async error')\n    }, 1000)\n  } catch(e) {\n    console.log(e, 'err')\n    console.log('continue...')\n  }\n}\n\nmain();\n")])])]),s("p",[e._v("以上代码会直接报错，不会被trycatch捕获。而async很好的解决了这个问题。\n我们只需要使用trycatch将await代码包裹即可。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function handler() {\n    const result1 = await asyncfunc1();\n    const result2 = await asyncfunc2(result1);\n    return result2;\n}\n// 错误捕捉\nhandler().catch(err => console.log(err))\n")])])]),s("p",[e._v("多么简洁的语法…… 用过promise的小伙伴肯定很熟悉这种语法了。")]),e._v(" "),s("h3",{attrs:{id:"在array-foreach-中使用await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在array-foreach-中使用await"}},[e._v("#")]),e._v(" 在Array.forEach()中使用await")]),e._v(" "),s("p",[e._v("初学async，兴奋地使用forEach实现了个异步方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function handler() {\n    let arr = [1, 2, 3, 4, 5]\n    arr.forEach(num => {\n        await setTimeout(() => {\n            console.log(num)\n        }, 1000);\n    })\n    console.log('success')\n}\nhandler()\n")])])]),s("p",[e._v("报错：Uncaught SyntaxError: await is only valid in async function")]),e._v(" "),s("p",[e._v("在forEach中就不算async了吗？！好，我改。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function handler() {\n    let arr = [1, 2, 3, 4, 5]\n    arr.forEach(async num => {\n        await setTimeout(() => {\n            console.log(num)\n        }, 1000);\n    })\n    console.log('success')\n}\nhandler()\n")])])]),s("p",[e._v("这下应该行了，看结果")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("success\n1\n2\n3\n4\n5\n")])])]),s("p",[e._v("……并没有实现异步。结合上一次await在forEach内部会显示不在async内的例子，"),s("strong",[e._v("我猜测")]),e._v("forEach内部可能自成一个新函数作用域，（仅为个人猜想）所以无法影响到外层。")]),e._v(" "),s("p",[e._v("所以理论上forEach不支持await，所以在forEach中使用await会报错，我们需要使用 for of 来代替forEach")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("async function handler() {\n    let arr = [1, 2, 3, 4, 5]\n    for(let i of arr){\n        console.log(i)\n    }\n    console.log('success')\n}\nhandler()\n")])])]),s("p",[e._v("正常打印结果")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1\n2\n3\n4\n5\nsuccess\n")])])]),s("h2",{attrs:{id:"结语"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结语"}},[e._v("#")]),e._v(" 结语")]),e._v(" "),s("p",[e._v("如果真正理解了上面的那些东西，那么基本上就掌握了js的异步编程了，只需要在实在中多多运用就可以进一步掌握和理解async了，恭喜自己又进了一步。")])])}),[],!1,null,null,null);n.default=t.exports}}]);